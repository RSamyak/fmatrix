---
title: "Estimating the Frechet Mean of a sample of ranked tree shapes: Simulations"
author: '---'
date: "23/04/2020"
output: html_document
---



We first load the dependencies:
```{r setup}
# source("Gen_Sim_funs.R")
library(fmatrix)

library(ape)
# devtools::install_github("JuliaPalacios/phylodyn")
library(phylodyn)
```


We generate samples of 100 trees on $n = 100$ tips.  We generate them using the `phylodyn` package using the method described in Maliet, Gascuel, and Lambert (2018).  This induces the Aldous' $\beta$-splitting model on the projection to tree shapes without ranks.

We will generate a sample each for $\beta = 100, 0, -1, -1.5, -1.9$
```{r simulate trees, eval=FALSE}
rand.seed <- 8964

treetypes <- c("balanced", "yule", "ab", "pda", "unbalanced")

n.sim <- 1000 # number of simulations

n.tip <- 100 # number of tips

n.model <- length(treetypes)

set.seed(rand.seed)
iso.Fmat.list <- list()
iso.tr.list <- list()
for (i in 1:length(treetypes)) {
  t.mode <- treetypes[i]
  print(t.mode)
  alpha <- 1
  eta <- 1
  epsilon <- 0.001 # the same value used in Maliet, Gascuel, and Lambert (2018)
  if (t.mode == 'balanced') {
    beta <- 100
  } else if (t.mode == 'yule') {
    beta <- 0
  } else if (t.mode == 'ab') {
    beta <- -1
  } else if (t.mode == 'pda') {
    beta <- -1.5
  } else if (t.mode == 'unbalanced') {
    beta <- -1.9
  }
  
  iso.tr.list[[i]] <- list()
  iso.Fmat.list[[i]] <-list()
  for (j  in 1:n.sim) {
    tmp.tr <- apTreeshape::simulate_tree(epsilon=epsilon, alpha=alpha, beta=beta, N=n.tip)
    iso.tr.list[[i]][[j]] <- tmp.tr
    iso.Fmat.list[[i]][[j]] <- gen_Fmat(tmp.tr)
  }
}

names(iso.tr.list) <- treetypes
names(iso.Fmat.list) <- treetypes

# save(rand.seed, treetypes, n.sim, n.tip, n.model, iso.tr.list, iso.Fmat.list, file="data/simulations-data.RData")
```

These simulations take a while.  We save them for reproducibility.


We will first try the for the sample generated from the AB model
```{r load data}
load("data/simulations-data.RData")

sampleF <- iso.Fmat.list[[3]]
```


We first try the method `nearby_Fmats`

```{r nearby_Fmats}
start.time <- Sys.time()
test <- meanF(sampleF)
lis1 <- nearby_Fmats(test, rd = .4, MAX.LENGTH = 500)
nearby_output <- closest_Fmat(test, lis1)

time1 <- Sys.time() - start.time
time1
```

We now try Simulated Annealing to estimate the Frechet mean.
```{r SA setup}
matrix_F <- matrix_list(sampleF)

energy <- function(state, matr=matrix_F, d="l2"){
  state.F <- reduce_to_vector(gen_Fmat(tree_from_matching(state)))
  
  if(d == "l1") distances <- sum(abs(matr - state.F))/n
  if(d == "l2") distances <- sqrt(sum((matr - state.F)**2)/n)
  
  return(sum(distances))
}

probab <- function(e1, e2, temp, eps = 0.0001){
  if(e2 < e1) return(1)
  # if(e1 == e2) cat("!")
  return(exp(-(e2-e1+eps)/temp))
}
```



We set up the initial chain parameters:
```{r SA initialise}
n <- n.tip

# set.seed(4564)
init <- rcoal(n, br = 1)

config <- matching(init)

e1 <- energy(config) # note sample has been set to default

# plot(init, direction = "downwards")
# tiplabels()
# nodelabels



max.iter <- 5000

init.temp <- 1000
temp <- init.temp
alpha <- 0.995

track <- T
if(track){
  track.config <- matrix(NA, nrow = max.iter, ncol = length(config))
  track.proposal <- matrix(NA, nrow = max.iter, ncol = length(config))
  track.energy.config <- rep(NA, max.iter)
  track.energy.proposal <- rep(NA, max.iter)
  track.temp <- rep(NA, max.iter)
  track.acceptance <- rep(NA, max.iter)
  track.prob <- rep(NA, max.iter)
}
```


We start the chain:
```{r SA main}
start.time <- Sys.time()
for(i in 1:max.iter){
  new <- proposal_matching(config)
  e2 <- energy(new)
  
  prob <- probab(e1, e2, temp)
  
  if(track){
    track.config[i,] <- config
    track.proposal[i,] <- new
    track.energy.config[i] <- e1
    track.energy.proposal[i] <- e2
    track.temp[i] <- temp
    track.prob[i] <- prob
  }
  
  if(runif(1) <= prob){
    config <- new
    e1 <- e2
    if(track){
      track.acceptance[i] <- 1
    }
  } else{
    if(track){
      track.acceptance[i] <- 0
    }
  }
  
  if(track & (i > 500)) if(sum(track.acceptance[(i-100):i])==0) break
  
  temp <- alpha*temp
  # cat(i,"\n")
}

time2 <- Sys.time() - start.time
time2
```


```{r save SA, eval=F}
save(energy, probab, matrix_F,
     init, config, max.iter, init.temp, alpha, track, 
     track.config, track.proposal, track.energy.config,
     track.energy.proposal, track.temp, track.acceptance, track.prob,
     # file = "sim/sim_10.RData"
     )
```


Plots for the Simulated Annealing chain:
```{r SA plots, dev='png'}
# proposal_matching(config)

plot(track.temp)

plot(track.acceptance)

plot(track.prob)

plot(track.energy.proposal - track.energy.config)

plot(track.energy.config)

# i <- which.min(track.energy.config)
# 
# # plotF(x) # do not know true mean here, x 
# plotF(gen_Fmat(tree_from_matching(config)))

# energy(config)
# energy(matching(mytree_from_F(x))) # do not know true mean here, x 


# library(ggplot2)
# 
# ggplot(data = NULL) + 
#   geom_line(aes(x = 1:max.iter, y = track.energy.proposal-track.energy.config))
# 
# ggplot(data = NULL) + 
#   geom_line(aes(x = 1:max.iter, y = track.energy.config))


# Simulations:
#
# 01 - l1, yule
# 02 - l2, yule
# 03 - l2, balanced
# 04 - l1, balanced
# 05 - l1, ab
# 06 - l2, ab
# 07 - l1, pda
# 08 - l2, pda
# 09 - l1, comb
# 10 - l2, comb

#



```

We compare the energies in both cases:
```{r}
energy(matching(mytree_from_F(nearby_output)))

# energy(config)
energy(track.config[which.min(track.energy.config),])


time1

time2
```

What if we use the first method to simply initialise the second method?  We can tune the parameters so that the `nearby_Fmats` does not try as hard to find the mean.

```{r combined}
start.time <- Sys.time()
test <- meanF(sampleF)
lis1 <- nearby_Fmats(test, rd = .45, MAX.LENGTH = 300)
nearby_output <- closest_Fmat(test, lis1)

time1 <- Sys.time() - start.time
time1

n <- n.tip

# set.seed(4564)
init <- mytree_from_F(nearby_output)

config <- matching(init)

e1 <- energy(config) # note sample has been set to default

# plot(init, direction = "downwards")
# tiplabels()
# nodelabels



max.iter <- 5000

init.temp <- 1000
temp <- init.temp
alpha <- 0.995

track <- T
if(track){
  track.config <- matrix(NA, nrow = max.iter, ncol = length(config))
  track.proposal <- matrix(NA, nrow = max.iter, ncol = length(config))
  track.energy.config <- rep(NA, max.iter)
  track.energy.proposal <- rep(NA, max.iter)
  track.temp <- rep(NA, max.iter)
  track.acceptance <- rep(NA, max.iter)
  track.prob <- rep(NA, max.iter)
}
start.time <- Sys.time()
for(i in 1:max.iter){
  new <- proposal_matching(config)
  e2 <- energy(new)
  
  prob <- probab(e1, e2, temp)
  
  if(track){
    track.config[i,] <- config
    track.proposal[i,] <- new
    track.energy.config[i] <- e1
    track.energy.proposal[i] <- e2
    track.temp[i] <- temp
    track.prob[i] <- prob
  }
  
  if(runif(1) <= prob){
    config <- new
    e1 <- e2
    if(track){
      track.acceptance[i] <- 1
    }
  } else{
    if(track){
      track.acceptance[i] <- 0
    }
  }
  
  if(track & (i > 500)) if(sum(track.acceptance[(i-100):i])==0) break
  
  temp <- alpha*temp
  # cat(i,"\n")
}

time2 <- Sys.time() - start.time
time2

```

```{r plot combined, dev='png'}
# proposal_matching(config)

plot(track.temp)

plot(track.acceptance)

plot(track.prob)

plot(track.energy.proposal - track.energy.config)

plot(track.energy.config)
```

We compare the energies in both cases:
```{r energies combined}
energy(matching(mytree_from_F(nearby_output)))

# energy(config)
energy(track.config[which.min(track.energy.config),])


time1

time2
```

We test initialisation using the sample medoid:

```{r sample-init}
start.time <- Sys.time()

nearby_output <- sampleF[[brute.mean(sampleF, sampleF, dist="l2")]]

time1 <- Sys.time() - start.time
time1

n <- n.tip

# set.seed(4564)
init <- mytree_from_F(nearby_output)

config <- matching(init)

e1 <- energy(config) # note sample has been set to default

# plot(init, direction = "downwards")
# tiplabels()
# nodelabels



max.iter <- 5000

init.temp <- 1000
temp <- init.temp
alpha <- 0.995

track <- T
if(track){
  track.config <- matrix(NA, nrow = max.iter, ncol = length(config))
  track.proposal <- matrix(NA, nrow = max.iter, ncol = length(config))
  track.energy.config <- rep(NA, max.iter)
  track.energy.proposal <- rep(NA, max.iter)
  track.temp <- rep(NA, max.iter)
  track.acceptance <- rep(NA, max.iter)
  track.prob <- rep(NA, max.iter)
}
start.time <- Sys.time()
for(i in 1:max.iter){
  new <- proposal_matching(config)
  e2 <- energy(new)
  
  prob <- probab(e1, e2, temp)
  
  if(track){
    track.config[i,] <- config
    track.proposal[i,] <- new
    track.energy.config[i] <- e1
    track.energy.proposal[i] <- e2
    track.temp[i] <- temp
    track.prob[i] <- prob
  }
  
  if(runif(1) <= prob){
    config <- new
    e1 <- e2
    if(track){
      track.acceptance[i] <- 1
    }
  } else{
    if(track){
      track.acceptance[i] <- 0
    }
  }
  
  if(track & (i > 500)) if(sum(track.acceptance[(i-100):i])==0) break
  
  temp <- alpha*temp
  # cat(i,"\n")
}

time2 <- Sys.time() - start.time
time2

```

```{r plot sample-init, dev='png'}
# proposal_matching(config)

plot(track.temp)

plot(track.acceptance)

plot(track.prob)

plot(track.energy.proposal - track.energy.config)

plot(track.energy.config)
```

We compare the energies in both cases:
```{r energies sample-init}
energy(matching(mytree_from_F(nearby_output)))

# energy(config)
energy(track.config[which.min(track.energy.config),])


time1

time2
```

