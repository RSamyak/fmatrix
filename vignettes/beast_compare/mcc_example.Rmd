---
title: "R Notebook"
output: html_notebook
---

Load libraries
```{r setup}
library(fmatrix)
library(phylodyn)
library("phangorn")
library("mvtnorm")
library("ape")
library(dplyr)
```


Import trees and generate F-matrices
```{r}
dataname <- "temp"
# dataname <- "temp2"
# dataname <- "temp3"
# dataname <- "temp4"

trees_list <- ape::read.nexus(paste0(dataname, ".trees"))

Fmat_list <- lapply(trees_list, gen_Fmat)

```


Load the TreeAnnotator MCC tree:
```{r}
mcc_tree <- ape::read.nexus(paste0(dataname, ".mcc"))
mcc_Fmat <- gen_Fmat(mcc_tree)
is.Fmat(mcc_Fmat)
plotF(mcc_Fmat)
```

Use `phangorn` to compute MCC tree:
```{r}
mcc_tree2 <- phangorn::mcc(trees_list)
mcc_Fmat2 <- gen_Fmat(mcc_tree2)
mcc_Fmat2 %>% plotF
```


Setup some initial functions for annealing:
```{r}
dist_type <- 1

matrix_F <- matrix_list(Fmat_list)
scale_vec <- scaling_vector(n, type = dist_type)
matrix_F <- diag(1/scale_vec) %*% matrix_F

energy <- function(state, matr=matrix_F, scale=scale_vec, d="l2"){
  Fmat <- gen_Fmat(tree_from_matching(state))
  n <- ncol(Fmat) + 1
  state.F <- reduce_to_vector(Fmat) / scale
  
  

  if(d == "l1") distances <-
    sum(abs( (matr - state.F) ))/n
  if(d == "l2") distances <-
    sqrt(sum(( (matr - state.F) )**2)/n)

  return(sum(distances))
}

probab <- function(e1, e2, temp, eps = 0.0001){
  if(e2 < e1) return(1)
  # if(e1 == e2) cat("!")
  return(exp(-(e2-e1+eps)/temp))
}
```

Setup annealing and chain parameters:
```{r}
# schedule <- "lin"
schedule <- "exp"
# schedule <- "log"

n <- 50

# set.seed(4564)
init <- rcoal(n, br = 1)

config <- matching(init)

e1 <- energy(config, scale = scale_vec) # note sample has been set to default

# plot(init, direction = "downwards")
# tiplabels()
# nodelabels



max.iter <- 10000

init.temp <- 1000
temp <- init.temp
alpha <- 0.995
```

Setup tracking parameters:
```{r}
track <- T
if(track){
  track.config <- matrix(NA, nrow = max.iter, ncol = length(config))
  track.proposal <- matrix(NA, nrow = max.iter, ncol = length(config))
  track.energy.config <- rep(NA, max.iter)
  track.energy.proposal <- rep(NA, max.iter)
  track.temp <- rep(NA, max.iter)
  track.acceptance <- rep(NA, max.iter)
  track.prob <- rep(NA, max.iter)
}
```

Main chain:
```{r}
start.time <- Sys.time()
for(i in 1:max.iter){
  new <- proposal_matching(config)
  e2 <- energy(new, scale = scale_vec)

  prob <- probab(e1, e2, temp)

  if(track){
    track.config[i,] <- config
    track.proposal[i,] <- new
    track.energy.config[i] <- e1
    track.energy.proposal[i] <- e2
    track.temp[i] <- temp
    track.prob[i] <- prob
  }

  if(runif(1) <= prob){
    config <- new
    e1 <- e2
    if(track){
      track.acceptance[i] <- 1
    }
  } else{
    if(track){
      track.acceptance[i] <- 0
    }
  }

  if(track & (i > 500)) if(sum(track.acceptance[(i-100):i])==0) break

  if(schedule == "exp") temp <- alpha*temp
  if(schedule == "log") temp <- init.temp/(1+log(1+i))
  if(schedule == "lin") temp <- init.temp/(1+i)
  # cat(i,"\n")
}

time2 <- Sys.time() - start.time
time2
```

Basic checks:
```{r}
plot(track.energy.config)

track.config[which.min(track.energy.config), ] %>% tree_from_matching %>% gen_Fmat %>% plotF
mcc_Fmat %>% plotF

energy(matching(mcc_tree2))
min(track.energy.config, na.rm = TRUE)
```

Save tracking file:
```{r}
save(track.config, track.proposal, track.energy.config, track.energy.proposal, track.prob, track.temp, track.acceptance, file = paste(dataname, schedule, "schedule.RData", sep = "_"))
```
